#!/usr/bin/env bash

# AI Commit - Generates conventional commit messages using AI
# ----------------------------------------------------------------------
# Generates a Conventionalâ€‘Commit message using a configurable AI
# provider, lets the user review/edit it, commits the changes and
# (optionally) pushes to the remote repository.
#
# Supported providers: openai, anthropic, gemini, groq, ollama, custom
#
# Usage:
#   aicommit [--no-push|-n]            # commit and push (default)
#   aicommit --no-push                 # commit only, do NOT push
#   aicommit -y|--yes                  # non-interactive; auto-use generated message
#   aicommit -p|--provider <name>      # use a specific AI provider
#   aicommit -r|--release [bump|ver]   # release: patch, minor, major, X.Y.Z, or auto
#   aicommit -h|--help                 # show this help
#   aicommit -V|--version              # show version information
# ----------------------------------------------------------------------

# Version information
VERSION="0.2.0"

# Display banner with rainbow-style ASCII art header
show_banner() {
    # Add some space from the top
    echo ""
    
    # Blue sky color code
    BLUE='\033[36m'
    RESET='\033[0m'
    local indent="  "
    local art_width=87

    center_under_art() {
        local text="$1"
        local len=${#text}
        local pad=0

        if (( art_width > len )); then
            pad=$(( (art_width - len) / 2 ))
        fi

        printf "%s%*s%s\n" "$indent" "$pad" "" "$text"
    }
    
    echo ""
    # ASCII art with blue sky color
    echo -e "${indent}${BLUE}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—${RESET}"
    echo -e "${indent}${BLUE}â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•         â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â• â•šâ•â•â–ˆâ–ˆâ•”â•â•â•${RESET}"
    echo -e "${indent}${BLUE}â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ•‘   ${RESET}"
    echo -e "${indent}${BLUE}â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ•â•â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ•‘   ${RESET}"
    echo -e "${indent}${BLUE}â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—         â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘   ${RESET}"
    echo -e "${indent}${BLUE}â•šâ•â•   â•šâ•â• â•šâ•â•â•â•â•â•          â•šâ•â•â•â•â•â•   â•šâ•â•â•â•â•â•  â•šâ•â•     â•šâ•â• â•šâ•â•     â•šâ•â• â•šâ•â•â•â•â•â•    â•šâ•â•   ${RESET}"
    echo ""
    # Centered version information
    version_text="v${VERSION}"
    center_under_art "$version_text"
    center_under_art "Generate conventional commit messages using AI"
    echo ""
}

# ---------- Colors ----------
C_RESET='\033[0m'
C_BOLD='\033[1m'
C_DIM='\033[2m'
C_GREEN='\033[32m'
C_RED='\033[31m'
C_YELLOW='\033[33m'
C_CYAN='\033[36m'
C_WHITE='\033[37m'

# Status indicators
STATUS_OK="${C_GREEN}â—${C_RESET}"
STATUS_MISS="${C_RED}â—${C_RESET}"
STATUS_WARN="${C_YELLOW}â—${C_RESET}"

show_help() {
    echo -e "${C_BOLD}aicommit${C_RESET} â€“ generate an AI commit message, commit and push."
    echo

    # --- Options ---
    echo -e "${C_BOLD}${C_CYAN}Options:${C_RESET}"
    echo -e "  ${C_GREEN}--provider${C_RESET}, ${C_GREEN}-p${C_RESET} ${C_DIM}<name>${C_RESET}  AI provider to use for this run."
    echo -e "  ${C_GREEN}--no-push${C_RESET},  ${C_GREEN}-n${C_RESET}          Do not push the commit to the remote."
    echo -e "  ${C_GREEN}--yes${C_RESET},      ${C_GREEN}-y${C_RESET}          Assume yes: auto-use the generated message."
    echo -e "  ${C_GREEN}--changelog${C_RESET}, ${C_GREEN}-c${C_RESET}          Update CHANGELOG.md with this commit."
    echo -e "  ${C_GREEN}--release${C_RESET},   ${C_GREEN}-r${C_RESET} ${C_DIM}[type]${C_RESET}  Create a release. Type: patch, minor, major, or X.Y.Z."
    echo -e "                              ${C_DIM}If omitted, AI auto-detects the bump type.${C_RESET}"
    echo -e "  ${C_GREEN}-V${C_RESET}, ${C_GREEN}--version${C_RESET}            Show version information."
    echo -e "  ${C_GREEN}-h${C_RESET}, ${C_GREEN}--help${C_RESET}               Show this help message."
    echo

    # --- Current config ---
    echo -e "${C_BOLD}${C_CYAN}Current configuration:${C_RESET}"

    # Resolve what the active default provider would be
    local cfg_default=""
    if [[ -f "$HOME/.aicommitrc" ]]; then
        cfg_default=$(grep -E '^AICOMMIT_PROVIDER=' "$HOME/.aicommitrc" 2>/dev/null | head -1 | cut -d= -f2 | tr -d '[:space:]"'"'" || true)
    fi
    local env_default="${AICOMMIT_PROVIDER:-}"
    local active_default=""
    local source_label=""

    if [[ -n "$env_default" ]]; then
        active_default="$env_default"
        source_label="env AICOMMIT_PROVIDER"
    elif [[ -n "$cfg_default" ]]; then
        active_default="$cfg_default"
        source_label="$HOME/.aicommitrc"
    fi

    if [[ -n "$active_default" ]]; then
        echo -e "  Default provider: ${C_BOLD}${C_GREEN}$active_default${C_RESET} ${C_DIM}(from $source_label)${C_RESET}"
    else
        echo -e "  Default provider: ${C_DIM}(none â€“ will auto-detect)${C_RESET}"
    fi

    if [[ -f "$HOME/.aicommitrc" ]]; then
        echo -e "  Config file:      ${C_GREEN}~/.aicommitrc${C_RESET} ${C_DIM}(found)${C_RESET}"
    else
        echo -e "  Config file:      ${C_DIM}~/.aicommitrc (not found)${C_RESET}"
    fi
    echo

    # --- Provider status table ---
    echo -e "${C_BOLD}${C_CYAN}Providers:${C_RESET}"
    echo -e "  ${C_DIM}STATUS  PROVIDER     MODEL                          ENV VAR${C_RESET}"

    # openai
    if [[ -n "${OPENAI_API_KEY:-}" ]]; then
        echo -e "  ${STATUS_OK}  ${C_BOLD}openai${C_RESET}       ${C_WHITE}gpt-4o-mini${C_RESET}                    ${C_GREEN}OPENAI_API_KEY${C_RESET} ${C_DIM}(set)${C_RESET}"
    else
        echo -e "  ${STATUS_MISS}  openai       ${C_DIM}gpt-4o-mini${C_RESET}                    ${C_RED}OPENAI_API_KEY${C_RESET} ${C_DIM}(not set)${C_RESET}"
    fi

    # anthropic
    if [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
        echo -e "  ${STATUS_OK}  ${C_BOLD}anthropic${C_RESET}    ${C_WHITE}claude-sonnet-4-20250514${C_RESET}       ${C_GREEN}ANTHROPIC_API_KEY${C_RESET} ${C_DIM}(set)${C_RESET}"
    else
        echo -e "  ${STATUS_MISS}  anthropic    ${C_DIM}claude-sonnet-4-20250514${C_RESET}       ${C_RED}ANTHROPIC_API_KEY${C_RESET} ${C_DIM}(not set)${C_RESET}"
    fi

    # gemini
    if [[ -n "${GEMINI_API_KEY:-}" ]]; then
        echo -e "  ${STATUS_OK}  ${C_BOLD}gemini${C_RESET}       ${C_WHITE}gemini-2.0-flash${C_RESET}              ${C_GREEN}GEMINI_API_KEY${C_RESET} ${C_DIM}(set)${C_RESET}"
    else
        echo -e "  ${STATUS_MISS}  gemini       ${C_DIM}gemini-2.0-flash${C_RESET}              ${C_RED}GEMINI_API_KEY${C_RESET} ${C_DIM}(not set)${C_RESET}"
    fi

    # groq
    if [[ -n "${GROQ_API_KEY:-}" ]]; then
        echo -e "  ${STATUS_OK}  ${C_BOLD}groq${C_RESET}         ${C_WHITE}llama-3.3-70b-versatile${C_RESET}        ${C_GREEN}GROQ_API_KEY${C_RESET} ${C_DIM}(set)${C_RESET}"
    else
        echo -e "  ${STATUS_MISS}  groq         ${C_DIM}llama-3.3-70b-versatile${C_RESET}        ${C_RED}GROQ_API_KEY${C_RESET} ${C_DIM}(not set)${C_RESET}"
    fi

    # ollama
    if command -v ollama &>/dev/null && curl -sf http://localhost:11434/api/tags &>/dev/null; then
        local ollama_model
        ollama_model=$(curl -sf http://localhost:11434/api/tags 2>/dev/null | jq -r '.models[0].name // "none"' 2>/dev/null || echo "none")
        echo -e "  ${STATUS_OK}  ${C_BOLD}ollama${C_RESET}       ${C_WHITE}${ollama_model}${C_RESET}    ${C_GREEN}server running${C_RESET}"
    elif command -v ollama &>/dev/null; then
        echo -e "  ${STATUS_WARN}  ollama       ${C_DIM}(auto-detect)${C_RESET}                  ${C_YELLOW}installed, server not running${C_RESET}"
    else
        echo -e "  ${STATUS_MISS}  ollama       ${C_DIM}(auto-detect)${C_RESET}                  ${C_RED}not installed${C_RESET}"
    fi

    # custom
    if [[ -n "${AICOMMIT_CUSTOM_API_URL:-}" && -n "${AICOMMIT_CUSTOM_API_KEY:-}" ]]; then
        local custom_model="${AICOMMIT_CUSTOM_MODEL:-gpt-4o-mini}"
        echo -e "  ${STATUS_OK}  ${C_BOLD}custom${C_RESET}       ${C_WHITE}${custom_model}${C_RESET}    ${C_GREEN}AICOMMIT_CUSTOM_API_URL${C_RESET} ${C_DIM}(set)${C_RESET}"
    else
        echo -e "  ${STATUS_MISS}  custom       ${C_DIM}(configurable)${C_RESET}                 ${C_RED}AICOMMIT_CUSTOM_API_URL + _KEY${C_RESET} ${C_DIM}(not set)${C_RESET}"
    fi
    echo

    # --- Quick reference ---
    echo -e "${C_BOLD}${C_CYAN}Quick setup:${C_RESET}"
    echo -e "  ${C_DIM}# Set a provider key${C_RESET}"
    echo -e "  export ${C_YELLOW}OPENAI_API_KEY${C_RESET}='sk-...'"
    echo -e ""
    echo -e "  ${C_DIM}# Set default provider${C_RESET}"
    echo -e "  echo '${C_YELLOW}AICOMMIT_PROVIDER${C_RESET}=openai' >> ~/.aicommitrc"
    echo -e ""
    echo -e "  ${C_DIM}# Override provider for a single run${C_RESET}"
    echo -e "  aicommit ${C_GREEN}--provider${C_RESET} anthropic"
}

set -euo pipefail

# ---------- Provider constants ----------
VALID_PROVIDERS="openai anthropic gemini groq ollama custom"
CONFIG_FILE="$HOME/.aicommitrc"

# ---------- Argument handling ----------
NO_PUSH=false
ASSUME_YES=false
UPDATE_CHANGELOG=false
CLI_PROVIDER=""
RELEASE_MODE=false
RELEASE_ARG=""

while (( "$#" )); do
    case "$1" in
        --no-push|-n)  NO_PUSH=true ;;
        --yes|-y)      ASSUME_YES=true ;;
        --changelog|-c) UPDATE_CHANGELOG=true ;;
        --provider|-p)
            shift
            if [[ -z "${1:-}" ]]; then
                echo "Error: --provider requires a value."
                echo "Valid providers: $VALID_PROVIDERS"
                exit 1
            fi
            CLI_PROVIDER="$1"
            ;;
        --release|-r)
            RELEASE_MODE=true
            if [[ -n "${2:-}" && ! "$2" =~ ^- ]]; then
                RELEASE_ARG="$2"
                shift
            fi
            ;;
        -V|--version)
            show_banner
            exit 0
            ;;
        -h|--help)
            show_banner
            show_help
            exit 0
            ;;
        *)
            echo "Warning: unknown option \"$1\" ignored."
            ;;
    esac
    shift
done

# ---------- Repository checks ----------
if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "Error: Not inside a git repository."
    exit 1
fi

# ---------- Environment checks ----------
if ! command -v jq &>/dev/null; then
    echo "Error: jq is not installed. Please install it first."
    echo "Ubuntu/Debian: sudo apt-get install jq"
    echo "macOS: brew install jq"
    exit 1
fi

# ---------- Provider helpers ----------
provider_available() {
    case "$1" in
        openai)    [[ -n "${OPENAI_API_KEY:-}" ]] ;;
        anthropic) [[ -n "${ANTHROPIC_API_KEY:-}" ]] ;;
        gemini)    [[ -n "${GEMINI_API_KEY:-}" ]] ;;
        groq)      [[ -n "${GROQ_API_KEY:-}" ]] ;;
        ollama)    command -v ollama &>/dev/null && curl -sf http://localhost:11434/api/tags &>/dev/null ;;
        custom)    [[ -n "${AICOMMIT_CUSTOM_API_URL:-}" && -n "${AICOMMIT_CUSTOM_API_KEY:-}" ]] ;;
        *)         return 1 ;;
    esac
}

detect_first_provider() {
    for p in openai anthropic gemini groq ollama custom; do
        if provider_available "$p"; then
            echo "$p"
            return 0
        fi
    done
    return 1
}

# ---------- Resolve provider ----------
PROVIDER=""

# 1. CLI flag
if [[ -n "$CLI_PROVIDER" ]]; then
    PROVIDER="$CLI_PROVIDER"
# 2. Environment variable
elif [[ -n "${AICOMMIT_PROVIDER:-}" ]]; then
    PROVIDER="$AICOMMIT_PROVIDER"
# 3. Config file
elif [[ -f "$CONFIG_FILE" ]]; then
    cfg_provider=$(grep -E '^AICOMMIT_PROVIDER=' "$CONFIG_FILE" 2>/dev/null | head -1 | cut -d= -f2 | tr -d '[:space:]"'"'" || true)
    if [[ -n "$cfg_provider" ]]; then
        PROVIDER="$cfg_provider"
    fi
fi

# 4. Auto-detect
if [[ -z "$PROVIDER" ]]; then
    PROVIDER=$(detect_first_provider || true)
fi

if [[ -z "$PROVIDER" ]]; then
    echo "Error: No AI provider configured or detected."
    echo
    echo "Set one of these environment variables:"
    echo "  export OPENAI_API_KEY='your-key'       (for OpenAI)"
    echo "  export ANTHROPIC_API_KEY='your-key'     (for Anthropic/Claude)"
    echo "  export GEMINI_API_KEY='your-key'        (for Google Gemini)"
    echo "  export GROQ_API_KEY='your-key'          (for Groq)"
    echo "  Install and run Ollama locally           (for Ollama)"
    echo "  export AICOMMIT_CUSTOM_API_URL + AICOMMIT_CUSTOM_API_KEY (for custom)"
    echo
    echo "Or set a default: echo 'AICOMMIT_PROVIDER=openai' >> ~/.aicommitrc"
    exit 1
fi

# Validate provider name
if ! echo "$VALID_PROVIDERS" | grep -qw "$PROVIDER"; then
    echo "Error: Unknown provider '$PROVIDER'."
    echo "Valid providers: $VALID_PROVIDERS"
    exit 1
fi

# Validate provider has required credentials
if ! provider_available "$PROVIDER"; then
    case "$PROVIDER" in
        openai)    echo "Error: OPENAI_API_KEY is not set." ;;
        anthropic) echo "Error: ANTHROPIC_API_KEY is not set." ;;
        gemini)    echo "Error: GEMINI_API_KEY is not set." ;;
        groq)      echo "Error: GROQ_API_KEY is not set." ;;
        ollama)    echo "Error: Ollama is not installed or the server is not running (http://localhost:11434)." ;;
        custom)    echo "Error: AICOMMIT_CUSTOM_API_URL and/or AICOMMIT_CUSTOM_API_KEY is not set." ;;
    esac
    exit 1
fi

# ---------- Provider API functions ----------
SYSTEM_PROMPT="You are a helpful assistant that generates git commit messages following the Conventional Commits specification. Focus on the actual code changes to determine the type and scope. Keep the message concise but complete, under 50 characters for the first line if possible."

build_user_prompt() {
    cat <<EOF
Generate a concise and descriptive git commit message for the following changes.
Follow the conventional commits specification (https://www.conventionalcommits.org/).
Use one of these types: feat, fix, docs, style, refactor, test, chore.

Rules:
1. Format first line as: <type>(<scope>): <description>
2. The first line should be under 50 characters if possible
3. After the first line, add a blank line and then bullet points for details
4. Each bullet point should start with a hyphen
5. Keep bullet points short and clear
6. Focus on WHAT changed and WHY, not HOW

Here are the changes:

$1
EOF
}

call_openai() {
    local user_prompt="$1"
    local payload
    payload=$(jq -n \
        --arg content "$SYSTEM_PROMPT" \
        --arg prompt "$user_prompt" \
        '{
            model: "gpt-4o-mini",
            messages: [
                {role: "system",   content: $content},
                {role: "user",     content: $prompt}
            ],
            temperature: 0.7,
            max_tokens: 2048
        }')

    local response
    response=$(curl -s https://api.openai.com/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d "$payload")

    if echo "$response" | jq -e '.error' &>/dev/null; then
        local err_msg
        err_msg=$(echo "$response" | jq -r '.error.message')
        echo "Error from OpenAI API: $err_msg" >&2
        return 1
    fi

    echo "$response" | jq -r '.choices[0].message.content'
}

call_anthropic() {
    local user_prompt="$1"
    local payload
    payload=$(jq -n \
        --arg system "$SYSTEM_PROMPT" \
        --arg prompt "$user_prompt" \
        '{
            model: "claude-sonnet-4-20250514",
            max_tokens: 2048,
            system: $system,
            messages: [
                {role: "user", content: $prompt}
            ]
        }')

    local response
    response=$(curl -s https://api.anthropic.com/v1/messages \
        -H "Content-Type: application/json" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "$payload")

    if echo "$response" | jq -e '.error' &>/dev/null; then
        local err_msg
        err_msg=$(echo "$response" | jq -r '.error.message')
        echo "Error from Anthropic API: $err_msg" >&2
        return 1
    fi

    echo "$response" | jq -r '.content[0].text'
}

call_gemini() {
    local user_prompt="$1"
    local combined_prompt="$SYSTEM_PROMPT

$user_prompt"
    local payload
    payload=$(jq -n \
        --arg text "$combined_prompt" \
        '{
            contents: [{
                parts: [{text: $text}]
            }],
            generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 2048
            }
        }')

    local response
    response=$(curl -s "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=$GEMINI_API_KEY" \
        -H "Content-Type: application/json" \
        -d "$payload")

    if echo "$response" | jq -e '.error' &>/dev/null; then
        local err_msg
        err_msg=$(echo "$response" | jq -r '.error.message')
        echo "Error from Gemini API: $err_msg" >&2
        return 1
    fi

    echo "$response" | jq -r '.candidates[0].content.parts[0].text'
}

call_groq() {
    local user_prompt="$1"
    local payload
    payload=$(jq -n \
        --arg content "$SYSTEM_PROMPT" \
        --arg prompt "$user_prompt" \
        '{
            model: "llama-3.3-70b-versatile",
            messages: [
                {role: "system",   content: $content},
                {role: "user",     content: $prompt}
            ],
            temperature: 0.7,
            max_tokens: 2048
        }')

    local response
    response=$(curl -s https://api.groq.com/openai/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $GROQ_API_KEY" \
        -d "$payload")

    if echo "$response" | jq -e '.error' &>/dev/null; then
        local err_msg
        err_msg=$(echo "$response" | jq -r '.error.message')
        echo "Error from Groq API: $err_msg" >&2
        return 1
    fi

    echo "$response" | jq -r '.choices[0].message.content'
}

call_ollama() {
    local user_prompt="$1"

    # Auto-detect the first available model
    local model
    model=$(curl -sf http://localhost:11434/api/tags | jq -r '.models[0].name // empty')
    if [[ -z "$model" ]]; then
        echo "Error: No Ollama models found. Pull a model first: ollama pull llama3.2" >&2
        return 1
    fi

    local payload
    payload=$(jq -n \
        --arg model "$model" \
        --arg system "$SYSTEM_PROMPT" \
        --arg prompt "$user_prompt" \
        '{
            model: $model,
            messages: [
                {role: "system",   content: $system},
                {role: "user",     content: $prompt}
            ],
            stream: false
        }')

    local response
    response=$(curl -s http://localhost:11434/api/chat \
        -H "Content-Type: application/json" \
        -d "$payload")

    if echo "$response" | jq -e '.error' &>/dev/null; then
        local err_msg
        err_msg=$(echo "$response" | jq -r '.error')
        echo "Error from Ollama: $err_msg" >&2
        return 1
    fi

    echo "$response" | jq -r '.message.content'
}

call_custom() {
    local user_prompt="$1"
    local model="${AICOMMIT_CUSTOM_MODEL:-gpt-4o-mini}"
    local payload
    payload=$(jq -n \
        --arg model "$model" \
        --arg content "$SYSTEM_PROMPT" \
        --arg prompt "$user_prompt" \
        '{
            model: $model,
            messages: [
                {role: "system",   content: $content},
                {role: "user",     content: $prompt}
            ],
            temperature: 0.7,
            max_tokens: 2048
        }')

    local response
    response=$(curl -s "$AICOMMIT_CUSTOM_API_URL" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $AICOMMIT_CUSTOM_API_KEY" \
        -d "$payload")

    if echo "$response" | jq -e '.error' &>/dev/null; then
        local err_msg
        err_msg=$(echo "$response" | jq -r '.error.message')
        echo "Error from custom API: $err_msg" >&2
        return 1
    fi

    echo "$response" | jq -r '.choices[0].message.content'
}

call_ai_provider() {
    local diff_text="$1"
    local user_prompt
    user_prompt=$(build_user_prompt "$diff_text")

    case "$PROVIDER" in
        openai)    call_openai "$user_prompt" ;;
        anthropic) call_anthropic "$user_prompt" ;;
        gemini)    call_gemini "$user_prompt" ;;
        groq)      call_groq "$user_prompt" ;;
        ollama)    call_ollama "$user_prompt" ;;
        custom)    call_custom "$user_prompt" ;;
    esac
}

# ---------- Release helpers ----------

RELEASE_SYSTEM_PROMPT="You are a semantic versioning assistant. You analyze git commit messages and determine the appropriate version bump according to Semantic Versioning (semver.org) and Conventional Commits.

Rules:
- MAJOR: commits with 'BREAKING CHANGE' in footer/body, or '!' after type/scope (e.g., 'feat!:', 'fix(api)!:')
- MINOR: commits with type 'feat' (new features)
- PATCH: commits with type 'fix', 'docs', 'style', 'refactor', 'perf', 'test', 'chore', or any other type

Respond with ONLY one word: major, minor, or patch. Nothing else."

ai_detect_bump() {
    local commits="$1"
    local current_version="$2"
    local user_prompt="Analyze these commit messages and determine the version bump type:

$commits

Current version: $current_version

Respond with exactly one word: major, minor, or patch"

    local saved_system="$SYSTEM_PROMPT"
    SYSTEM_PROMPT="$RELEASE_SYSTEM_PROMPT"

    local result
    case "$PROVIDER" in
        openai)    result=$(call_openai "$user_prompt") ;;
        anthropic) result=$(call_anthropic "$user_prompt") ;;
        gemini)    result=$(call_gemini "$user_prompt") ;;
        groq)      result=$(call_groq "$user_prompt") ;;
        ollama)    result=$(call_ollama "$user_prompt") ;;
        custom)    result=$(call_custom "$user_prompt") ;;
    esac

    SYSTEM_PROMPT="$saved_system"

    result=$(echo "$result" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')
    if [[ "$result" != "major" && "$result" != "minor" && "$result" != "patch" ]]; then
        echo "Error: AI returned unexpected bump type: '$result'" >&2
        return 1
    fi
    echo "$result"
}

do_release() {
    local script_path
    script_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

    # Must be in a git repo
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        echo "Error: Not inside a git repository."
        exit 1
    fi

    # Must be on main branch
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    if [[ "$current_branch" != "main" ]]; then
        echo -e "${C_RED}Error:${C_RESET} Releases must be created from the ${C_BOLD}main${C_RESET} branch."
        echo "  Current branch: $current_branch"
        exit 1
    fi

    # If there are uncommitted changes, run the normal commit flow first
    if ! git diff-index --quiet HEAD -- 2>/dev/null || [[ -n "$(git ls-files --others --exclude-standard)" ]]; then
        echo -e "${C_CYAN}Uncommitted changes detected. Running commit flow first...${C_RESET}"
        echo ""

        local full_diff
        full_diff=$(get_all_changes)
        if [[ -z "$full_diff" ]]; then
            echo "No changes detected."
        else
            echo "Analyzing changes and generating commit message (provider: $PROVIDER)..."
            local gen_msg
            gen_msg=$(call_ai_provider "$full_diff") || exit 1
            gen_msg=$(echo "$gen_msg" | sed '/^```/d')

            echo -e "\nAI-generated commit message:"
            echo "--------------------------------"
            echo -e "$gen_msg"
            echo "--------------------------------"

            local final_msg="$gen_msg"
            if ! $ASSUME_YES; then
                read -p "Use this commit message? [Y/n/e] (Y = use, n = abort, e = edit): " choice
                choice=$(echo "$choice" | tr '[:upper:]' '[:lower:]')
                case "$choice" in
                    n) echo "Release aborted."; exit 0 ;;
                    e)
                        local tmpfile
                        tmpfile=$(mktemp /tmp/commit_msg.XXXXXX)
                        echo "$gen_msg" > "$tmpfile"
                        ${EDITOR:-nano} "$tmpfile"
                        final_msg=$(<"$tmpfile")
                        rm -f "$tmpfile"
                        ;;
                    *) final_msg="$gen_msg" ;;
                esac
            fi

            git add -A
            git commit -m "$final_msg"
            echo -e "\n${C_GREEN}Changes committed.${C_RESET}"
            echo ""
        fi
    fi

    # Get latest tag
    local latest_tag
    latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
    if [[ -z "$latest_tag" ]]; then
        echo -e "${C_YELLOW}No existing version tags found.${C_RESET}"
        local initial_ver="0.1.0"
        if ! $ASSUME_YES; then
            read -p "Enter initial version [${initial_ver}]: " user_ver
            if [[ -n "$user_ver" ]]; then
                user_ver="${user_ver#v}"
                if ! [[ "$user_ver" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    echo -e "${C_RED}Error:${C_RESET} Invalid version format. Use X.Y.Z"
                    exit 1
                fi
                initial_ver="$user_ver"
            fi
        fi
        if git rev-parse "v${initial_ver}" >/dev/null 2>&1; then
            echo -e "${C_YELLOW}Tag v${initial_ver} already exists, using it as baseline.${C_RESET}"
            latest_tag="v${initial_ver}"
        else
            echo "Creating initial tag v${initial_ver}..."
            git tag -a "v${initial_ver}" -m "Initial release v${initial_ver}"
            latest_tag="v${initial_ver}"
            echo -e "${C_GREEN}Created tag v${initial_ver}${C_RESET}"
        fi
        echo ""
    fi

    local current_ver="${latest_tag#v}"
    if ! [[ "$current_ver" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
        echo -e "${C_RED}Error:${C_RESET} Latest tag '$latest_tag' is not valid semver."
        exit 1
    fi

    local cur_major="${BASH_REMATCH[1]}"
    local cur_minor="${BASH_REMATCH[2]}"
    local cur_patch="${BASH_REMATCH[3]}"

    local bump_type=""
    local next_version=""

    if [[ -z "$RELEASE_ARG" ]]; then
        # AI auto-detect
        local commits
        commits=$(git log "${latest_tag}..HEAD" --pretty=format:"%s" 2>/dev/null)
        if [[ -z "$commits" ]]; then
            echo -e "${C_RED}Error:${C_RESET} No new commits since ${latest_tag}."
            exit 1
        fi
        local commit_count
        commit_count=$(echo "$commits" | wc -l)
        echo "Analyzing $commit_count commit(s) since ${latest_tag} to determine bump type (provider: $PROVIDER)..."
        bump_type=$(ai_detect_bump "$commits" "$current_ver") || exit 1
    elif [[ "$RELEASE_ARG" =~ ^(patch|minor|major)$ ]]; then
        bump_type="$RELEASE_ARG"
    elif [[ "$RELEASE_ARG" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        next_version="$RELEASE_ARG"
        bump_type="explicit"
    else
        echo -e "${C_RED}Error:${C_RESET} Invalid release argument '$RELEASE_ARG'."
        echo "  Usage: aicommit --release [patch|minor|major|X.Y.Z]"
        exit 1
    fi

    # Calculate next version if not explicit
    if [[ -z "$next_version" ]]; then
        case "$bump_type" in
            major) next_version="$((cur_major + 1)).0.0" ;;
            minor) next_version="${cur_major}.$((cur_minor + 1)).0" ;;
            patch) next_version="${cur_major}.${cur_minor}.$((cur_patch + 1))" ;;
        esac
    fi

    # Count commits since last tag
    local commit_count
    commit_count=$(git rev-list "${latest_tag}..HEAD" --count 2>/dev/null || echo "0")

    # Show release plan
    echo ""
    echo -e "${C_BOLD}${C_CYAN}Release Plan:${C_RESET}"
    echo "  -----------------------------------------------"
    echo -e "  Current version: ${C_BOLD}${current_ver}${C_RESET} (${latest_tag})"
    echo -e "  New version:     ${C_BOLD}${C_GREEN}${next_version}${C_RESET}"
    echo -e "  Bump type:       ${C_BOLD}${bump_type}${C_RESET}"
    echo -e "  Changes since ${latest_tag}: ${commit_count} commit(s)"
    echo "  -----------------------------------------------"
    echo ""

    if ! $ASSUME_YES; then
        read -p "Proceed with release v${next_version}? [Y/n] " reply
        reply=$(echo "$reply" | tr '[:upper:]' '[:lower:]')
        if [[ "$reply" == "n" ]]; then
            echo "Release cancelled."
            exit 0
        fi
    fi

    # 1. Update VERSION in the aicommit script
    echo "Updating VERSION to ${next_version} in aicommit..."
    sed -i "s/^VERSION=\".*\"/VERSION=\"${next_version}\"/" "$script_path"

    # 2. Update CHANGELOG.md
    local changelog_file="CHANGELOG.md"
    local release_date
    release_date=$(date +%Y-%m-%d)

    if [[ -f "$changelog_file" ]]; then
        if grep -A 10 "## \[Unreleased\]" "$changelog_file" | grep -q "^###"; then
            echo "Updating CHANGELOG.md for v${next_version}..."
            local backup="${changelog_file}.bak"
            cp "$changelog_file" "$backup"

            local unreleased_content
            unreleased_content=$(awk '
                /## \[Unreleased\]/ { in_unreleased=1; next }
                /## \[/ { in_unreleased=0 }
                in_unreleased && /^###/ { print; getline; while(/^-/) { print; if(getline <= 0) break } }
            ' "$changelog_file")

            if [[ -n "$unreleased_content" ]]; then
                awk -v version="$next_version" -v date="$release_date" -v content="$unreleased_content" '
                    /## \[Unreleased\]/ {
                        print
                        print ""
                        print "## [" version "] - " date
                        print content
                        in_unreleased=1
                        next
                    }
                    in_unreleased && /^## \[/ {
                        in_unreleased=0
                    }
                    !in_unreleased { print }
                ' "$backup" > "$changelog_file"
            fi
            rm -f "$backup"
        else
            echo "No unreleased changes in CHANGELOG.md. Skipping CHANGELOG update."
        fi
    fi

    # 3. Commit the release
    echo "Committing release v${next_version}..."
    git add -A
    git commit -m "chore(release): v${next_version}" || true

    # 4. Create annotated tag
    echo "Creating tag v${next_version}..."
    git tag -a "v${next_version}" -m "Release v${next_version}"

    # 5. Push commit + tag
    echo "Pushing to origin..."
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    git push origin "$current_branch"
    git push origin "v${next_version}"

    # 6. Create GitHub Release if gh CLI is available
    if command -v gh &>/dev/null; then
        echo "Creating GitHub Release..."
        local release_notes=""
        if [[ -f "$changelog_file" ]]; then
            release_notes=$(sed -n "/## \[${next_version}\]/,/## \[/p" "$changelog_file" | sed '1d;$d' | sed '/^$/d')
        fi
        if [[ -n "$release_notes" ]]; then
            gh release create "v${next_version}" \
                --title "v${next_version}" \
                --notes "$release_notes" 2>/dev/null \
                && echo -e "${C_GREEN}GitHub Release created.${C_RESET}" \
                || echo -e "${C_YELLOW}Warning: GitHub Release creation failed. You can create it manually.${C_RESET}"
        else
            gh release create "v${next_version}" \
                --title "v${next_version}" \
                --generate-notes 2>/dev/null \
                && echo -e "${C_GREEN}GitHub Release created.${C_RESET}" \
                || echo -e "${C_YELLOW}Warning: GitHub Release creation failed. You can create it manually.${C_RESET}"
        fi
    fi

    echo ""
    echo -e "${C_GREEN}${C_BOLD}Release v${next_version} complete!${C_RESET}"
}

# ---------- Constants ----------
MAX_CHAR_LIMIT=20000          # Approximate token limit accounting for OpenAI's token limit
MAX_FILE_CHAR_LIMIT=2000      # Character limit per file content
MAX_DIFF_LINES=100            # Maximum number of diff lines per file

# ---------- Helper functions ----------
truncate_text() {
    local text="$1"
    local max_chars=$2

    if (( ${#text} > max_chars )); then
        local truncated="${text:0:$((max_chars-50))}"
        truncated+="\n... [truncated - $(( (${#text} - max_chars) / 1000 ))K chars omitted] ...\n"
        echo -e "$truncated"
    else
        echo -e "$text"
    fi
}

truncate_diff() {
    local diff_output="$1"
    local max_lines=$2

    local line_count
    line_count=$(echo "$diff_output" | wc -l)

    if (( line_count > max_lines )); then
        local half=$((max_lines / 2))
        local first_part last_part
        first_part=$(echo "$diff_output" | head -n "$half")
        last_part=$(echo "$diff_output" | tail -n "$half")
        echo -e "$first_part"
        echo "... [truncated - $((line_count - max_lines)) lines omitted] ..."
        echo -e "$last_part"
    else
        echo -e "$diff_output"
    fi
}

update_changelog() {
    local commit_msg="$1"
    local changelog_file="CHANGELOG.md"

    # Parse commit message to extract type and description
    local first_line=$(echo "$commit_msg" | head -n 1)
    local commit_type=$(echo "$first_line" | grep -oP '^[a-z]+' || echo "chore")
    local commit_desc=$(echo "$first_line" | sed 's/^[a-z]\+(\?[^)]*)\?: //')

    # Get the short hash of the last commit
    local commit_hash=$(git rev-parse --short=7 HEAD)

    # Map commit type to changelog category
    local category
    case "$commit_type" in
        feat)     category="Added" ;;
        fix)      category="Fixed" ;;
        *)        category="Changed" ;;
    esac

    # Create CHANGELOG.md if it doesn't exist
    if [[ ! -f "$changelog_file" ]]; then
        cat > "$changelog_file" << 'EOF'
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

EOF
    fi

    # Check if CHANGELOG was modified in the commit we just made
    # If user manually edited it, we should skip auto-update to avoid conflicts
    if git diff HEAD~1 HEAD --name-only 2>/dev/null | grep -q "^CHANGELOG.md$"; then
        echo "Warning: $changelog_file was modified in this commit. Skipping auto-update."
        return 1
    fi

    # Create entry
    local entry="- $commit_desc ($commit_hash)"

    # Read the current CHANGELOG
    local changelog_content=$(<"$changelog_file")

    # Check if [Unreleased] section exists
    if ! echo "$changelog_content" | grep -q "## \[Unreleased\]"; then
        # Add [Unreleased] section at the top after the header
        local header=$(echo "$changelog_content" | sed -n '1,/^$/p')
        local rest=$(echo "$changelog_content" | sed '1,/^$/d')
        changelog_content="${header}

## [Unreleased]

${rest}"
    fi

    # Check if category exists under [Unreleased]
    if echo "$changelog_content" | sed -n '/## \[Unreleased\]/,/## \[/p' | grep -q "### $category"; then
        # Category exists - insert entry after the category header
        local temp_file=$(mktemp)
        awk -v cat="### $category" -v entry="$entry" '
            /## \[Unreleased\]/ { in_unreleased=1 }
            /## \[/ && !/## \[Unreleased\]/ { in_unreleased=0 }
            in_unreleased && $0 ~ cat {
                print
                getline
                print entry
                print $0
                next
            }
            { print }
        ' "$changelog_file" > "$temp_file"
        mv "$temp_file" "$changelog_file"
    else
        # Category doesn't exist - create it under [Unreleased]
        local temp_file=$(mktemp)
        awk -v cat="### $category" -v entry="$entry" '
            /## \[Unreleased\]/ {
                print
                print ""
                print cat
                print entry
                inserted=1
                next
            }
            { print }
        ' "$changelog_file" > "$temp_file"
        mv "$temp_file" "$changelog_file"
    fi

    # Stage the CHANGELOG and amend the commit
    git add "$changelog_file"
    git commit --amend --no-edit

    return 0
}

# ---------- Gather diff ----------
get_all_changes() {
    local changes="" total_chars=0 truncated=false

    # Summary header
    changes+="=== Summary of Changes ===\n"

    # ---- Staged ----
    local staged=$(git diff --cached --name-status)
    if [[ -n $staged ]]; then
        changes+="=== Staged Changes ===\n"
        changes+="Files changed:\n$staged\n\n"

        local staged_diff=$(git diff --cached --color=never)
        local staged_diff_truncated=$(truncate_diff "$staged_diff" $MAX_DIFF_LINES)
        changes+="Detailed changes:\n$staged_diff_truncated\n\n"
        total_chars=$((total_chars + ${#staged_diff_truncated}))
    fi

    # ---- Unstaged ----
    if (( total_chars < MAX_CHAR_LIMIT * 3 / 4 )); then
        local unstaged=$(git diff --name-status)
        if [[ -n $unstaged ]]; then
            changes+="=== Unstaged Changes ===\n"
            changes+="Files changed:\n$unstaged\n\n"

            local unstaged_diff=$(git diff --color=never)
            local unstaged_diff_truncated=$(truncate_diff "$unstaged_diff" $MAX_DIFF_LINES)
            changes+="Detailed changes:\n$unstaged_diff_truncated\n\n"
            total_chars=$((total_chars + ${#unstaged_diff_truncated}))
        fi
    else
        truncated=true
        changes+="\n... [Some changes omitted due to size limitations] ...\n\n"
    fi

    # ---- Untracked ----
    if (( total_chars < MAX_CHAR_LIMIT * 7 / 8 )) && ! $truncated; then
        local untracked=$(git ls-files --others --exclude-standard)
        if [[ -n $untracked ]]; then
            changes+="=== Untracked Files ===\n"
            local file_limit=5 count=0
            while IFS= read -r file && (( count < file_limit )) && (( total_chars < MAX_CHAR_LIMIT )); do
                [[ -f $file ]] || continue
                ((count++))
                changes+="New file: $file\n"
                if file "$file" | grep -q "text"; then
                    local content truncated_content
                    content=$(cat "$file")
                    truncated_content=$(truncate_text "$content" $MAX_FILE_CHAR_LIMIT)
                    changes+="Content:\n$truncated_content\n\n"
                    total_chars=$((total_chars + ${#truncated_content}))
                else
                    changes+="(Binary file)\n\n"
                fi
                (( total_chars > MAX_CHAR_LIMIT * 9 / 10 )) && break
            done <<< "$untracked"

            local total_untracked
            total_untracked=$(echo "$untracked" | wc -l)
            (( total_untracked > file_limit )) && \
                changes+="Note: Only showing $count of $total_untracked untracked files\n"
        fi
    else
        changes+="\n... [Untracked files omitted due to size limitations] ...\n\n"
    fi

    # Final truncation safeguard
    if (( ${#changes} > MAX_CHAR_LIMIT )); then
        truncate_text "$changes" $MAX_CHAR_LIMIT
    else
        echo -e "$changes"
    fi
}

# ---------- Main flow ----------

# If release mode, run release flow and exit
if $RELEASE_MODE; then
    do_release
    exit 0
fi

FULL_DIFF=$(get_all_changes)

if [[ -z $FULL_DIFF ]]; then
    echo "No changes detected."
    exit 0
fi

echo "Analyzing changes and generating commit message (provider: $PROVIDER)..."

GENERATED_MSG=$(call_ai_provider "$FULL_DIFF") || exit 1
GENERATED_MSG=$(echo "$GENERATED_MSG" | sed '/^```/d')   # strip possible fences

# ---- User review ----
echo -e "\nAIâ€‘generated commit message:"
echo "--------------------------------"
echo -e "$GENERATED_MSG"
echo "--------------------------------"

if $ASSUME_YES; then
    FINAL_MSG="$GENERATED_MSG"
else
    read -p "Use this commit message? [Y/n/e] (Y = use, n = abort, e = edit): " choice
    choice=$(echo "$choice" | tr '[:upper:]' '[:lower:]')

    case "$choice" in
        n) echo "Commit aborted."; exit 0 ;;
        e)
            TMPFILE=$(mktemp /tmp/commit_msg.XXXXXX)
            echo "$GENERATED_MSG" > "$TMPFILE"
            ${EDITOR:-nano} "$TMPFILE"
            FINAL_MSG=$(<"$TMPFILE")
            rm -f "$TMPFILE"
            ;;
        *) FINAL_MSG="$GENERATED_MSG" ;;
    esac
fi

# ---- Final confirmation ----
echo -e "\nFinal commit message:"
echo "--------------------------------"
echo -e "$FINAL_MSG"
echo "--------------------------------"
if ! $ASSUME_YES; then
    read -p "Press Enter to commit (Ctrl+C to abort) â€¦ "
fi

# ---- Commit ----
git add -A
git commit -m "$FINAL_MSG"

echo -e "\nâœ… Changes committed successfully!"

# ---- Update CHANGELOG if flag is set ----
if $UPDATE_CHANGELOG; then
    echo "Updating CHANGELOG.md..."
    if update_changelog "$FINAL_MSG"; then
        echo "âœ… CHANGELOG.md updated and commit amended."
    else
        echo "âš ï¸  CHANGELOG.md update skipped."
    fi
fi

# ---- Optional push ----
if ! $NO_PUSH; then
    echo "Pushing to remote..."
    # Push to the current branch's upstream (if set); otherwise fall back to origin HEAD
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    if git rev-parse --abbrev-ref "@{u}" &>/dev/null; then
        # Upstream exists â€“ use default push (preserves upstream config)
        if git push; then
            echo "ğŸš€ Push completed."
        else
            echo "âš ï¸ Push failed."
            exit 1
        fi
    else
        # No upstream configured â€“ push to origin explicitly
        if git push origin "$CURRENT_BRANCH"; then
            echo "ğŸš€ Push completed."
        else
            echo "âš ï¸ Push failed."
            exit 1
        fi
    fi
else
    echo "âš¡ï¸ Push skipped due to --no-push flag."
fi

# ---- History logging (optional) ----
# Append the exact command used for future reference.
echo "git commit -m \"$FINAL_MSG\"" >> ~/.history

exit 0
